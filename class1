
# 主要就是各种排序与例题 Python的实现版本
import random
arr = [ random.randint(0,1000) for i in range(random.randint(1, 50))]
print(arr)

def check(arr):
    for i in range(len(arr)-1):
        if arr[i]>arr[i+1]:
            raise
    return True

def bubbleSort(arr):
    for i in range(0, len(arr)-1):
        for j in range(0, len(arr)-i-1):
            if arr[j]>arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
bubbleSort(arr)

def select_sort(arr):
    for i in range(0, len(arr)-1):
        for j in range(i+1, len(arr)):
            if arr[i]>arr[j]:
                arr[j], arr[i] = arr[i], arr[j]  
select_sort(arr)

def insert_sort(arr):
    for i in range(1, len(arr)):
        for j in range(i, 0, -1):
            if arr[j] < arr[j-1]:
                arr[j], arr[j-1] = arr[j-1], arr[j]
            else:
                break
insert_sort(arr)
check(arr)
print(arr)
    

def merge_sort(arr):
    def merge(a, b):
        c = []
        i = j = 0 
        while i < len(a) and j < len(b):
            if a[i]>=b[j]:
                c.append(b[j])
                j += 1
            else:
                c.append(a[i])
                i += 1
        c =  c + a[i:] + b[j:]
        return c
    
    def recusive(arr):
        
        if len(arr) == 1:
            return arr
        mid = len(arr)>>1
        return merge(recusive(arr[:mid]), recusive(arr[mid:]))
     
    return recusive(arr)

merge_sort(arr)


def xiaohe(arr): 小和问题
    
    # 这个是自己的思路 主要是b[j]作为对比，而视频中以a[i]作为对比，更加简洁
    def merge1(a, b):
        c = []
        i = j = 0
        ans = he = 0
        while i<len(a) and j<len(b):
            if a[i]<b[j]:
                he += a[i]
                c.append(a[i])
                i += 1
            else:
                c.append(b[j])
                ans += he
                j += 1
        c = c + a[i:] + b[j:]
        ans += he*(len(b[j:]))
        return c, ans
    
    def merge2(a, b):
        c = []
        i = j = 0
        ans = 0
        while i<len(a) and j<len(b):
            if a[i]<b[j]:
                ans += a[i]*len(b[j:])
                c.append(a[i])
                i += 1
            else:
                c.append(b[j])
                j += 1
        c = c + a[i:] + b[j:]
        return c, ans
    
    def recursive1(arr):
        
        if len(arr) == 1:
            return arr, 0
        mid = len(arr)>>1
        c1, sum1 = recursive1(arr[:mid])
        c2, sum2 = recursive1(arr[mid:])
        c3, sum3 = merge1(c1, c2)       
        return c3, sum3 + sum2 + sum1
    
    def recursive2(arr):
        if len(arr) == 1:
            return arr, 0
        mid = len(arr)>>1
        c1, sum1 = recursive2(arr[:mid])
        c2, sum2 = recursive2(arr[mid:])
        c3, sum3 = merge2(c1, c2)
        return c3, sum3 + sum2 + sum1

    print(recursive1(arr))
    print(recursive2(arr))
  
  # 逆序对同理
  def nixuwenti(arr):
    
    def merge(a, b):
        c = []
        i = j = 0
        ans = []
        while i<len(a) and j<len(b):
            if a[i]<=b[j]:
                c.append(a[i])
                i += 1
            else:
                ans = ans + [(a[k1], b[j]) for k1 in range(i, len(a))]
                c.append(b[j])
                j += 1
        c = c + a[i:] + b[j:]
        return c, ans
    
    def recursive(arr):
        
        if len(arr) == 1:
            return arr, []
        mid = len(arr)>>1
        c1, sum1 = recursive(arr[:mid])
        c2, sum2 = recursive(arr[mid:])
        c3, sum3 = merge(c1, c2)       
        return c3, sum1 + sum2 + sum3
    
   
    print(recursive(arr))

 
  
